---
title: "Bayesian Structural Time Series"
author: "Isaac Vernon"
date: "6/15/2021"
output: html_document
---

Add the various packages for the work
```{r, hide=TRUE}
library(lubridate)
library(bsts)
library(dplyr)
library(ggplot2)
library(forecast)
library(readxl)
```


Load in the data
```{r}
d = read.csv("/Users/Isaac/Documents/GitHub/W210-Capstone/data/TrainingData/fulldata.csv")

gdp = read.csv("/Users/Isaac/Documents/GitHub/W210-Capstone/data/CleanData/GDP.csv")
```

Start working on BSTS 
```{r}
# RealGDP only
d = d[d$INDICATOR == "RealGDP", ]
d = d[complete.cases(d[, c(2, 5, 63, 64)]), ]
y = d$actual
ss <- AddLocalLinearTrend(list(), y)
ss <- AddSeasonal(ss, y, nseasons = 1)
bsts.model = bsts(actual ~ FORECASTER.ID + QUARTER + pred_average + pred_var + 1, state.specification = ss, data =
                d, niter = 500, ping=0, seed=2016)
```


This Example (Probably the same)
https://www.unofficialgoogledatascience.com/2017/07/fitting-bayesian-structural-time-series.html

```{r, hide=TRUE}
library(bsts)

d = read.csv("/Users/Isaac/Documents/GitHub/W210-Capstone/data/TrainingData/fulldata.csv")

gdp = read.csv("/Users/Isaac/Documents/GitHub/W210-Capstone/data/CleanData/GDP.csv")

actuals = read_excel("/Users/Isaac/Documents/GitHub/W210-Capstone/data/RawData/GDPC1.xls")

timeseries = read.csv("/Users/Isaac/Documents/GitHub/W210-Capstone/data/CleanData/QuarterlyFredWithItems.csv")
```


```{r}
d = d[d$INDICATOR == "RealGDP", ]
d = d[complete.cases(d[, c(2, 5, 63, 64)]), ]
y = d$actual
ss <- AddLocalLinearTrend(list(), y)
ss <- AddSeasonal(ss, y, nseasons = 1)
```

```{r}
#d = d[, c(2, 5, 57, 63, 64)]
model3 <- bsts(y,
               state.specification = ss,
               niter = 1000)
```

```{r}
actuals = actuals[-(1:10),]
```

```{r}
y = as.numeric(actuals[1:72, 2]$...2)
ss <- AddLocalLinearTrend(list(), y)
ss <- AddSeasonal(ss, y, nseasons = 1)
```

```{r}
model3 <- bsts(y,
               state.specification = ss,
               niter = 1000)
```

```{r}
var(y)
plot(y)
lines(y)
```

https://minimizeregret.com/post/2020/06/07/rediscovering-bayesian-structural-time-series/

```{r}
library(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

llt_model <- stan_model("local_linear_trend.stan",
                        model_name = "local_linear_trend")
```


Example from StitchFix, using new data
```{r}
library(bsts)
library(dplyr)


timeseries = read.csv("/Users/Isaac/Documents/GitHub/W210-Capstone/data/CleanData/QuarterlyFredWithItems.csv")

```

```{r}
y = timeseries$GDPC1_PCH[1:286]
actuals = timeseries$GDPC1_PCH[287:296]
ss <- AddLocalLinearTrend(list(), y)
ss <- AddSeasonal(ss, y, nseasons = 4)
bsts.model <- bsts(y, state.specification = ss, niter = 500, ping=0, seed=2016)

```

```{r}
burn <- SuggestBurn(0.1, bsts.model)
p <- predict.bsts(bsts.model, horizon = 10, burn = burn, quantiles = c(.025, .975))

```

```{r}
### Actual versus predicted
d2 <- data.frame(
    # fitted values and predictions
    c(as.numeric(-colMeans(bsts.model$one.step.prediction.errors[-(1:burn),])+y),  
    as.numeric(p$mean)),
    # actual data and dates 
    as.numeric(timeseries$GDPC1_PCH))
names(d2) <- c("Fitted", "Actual")

### MAPE (mean absolute percentage error)
MAPE <- d2 %>% summarise(MAPE=mean(abs(Actual-Fitted)/Actual))


### Plot actual versus predicted with credible intervals for the holdout period
plot(d2$Fitted, type="l")
plot(d2$Actual, type="l")
```


Try the Variable Selection Time Series (Shifts each GDP value a quarter forward -- to remove present time dependencies)
```{r}
timeseries = transform(timeseries, GDPC1_PCH=lead(GDPC1_PCH))
timeseries2 = timeseries[149:296, 2:18]

newdata = timeseries[276:290, 3:18]

ss <- AddLocalLinearTrend(list(), timeseries2$GDPC1_PCH)
ss <- AddSeasonal(ss, timeseries2$GDPC1_PCH, nseasons = 4)
bsts.reg <- bsts(GDPC1_PCH ~ ., state.specification = ss, data =
                timeseries2, niter = 500, ping=0, seed=2016)

p <- predict.bsts(bsts.reg, newdata=newdata, horizon = 10, burn = burn, quantiles = c(.025, .975))

preds = as.numeric(p$mean)
```


```{r}
plot(preds, type="l")
plot(timeseries$GDPC1_PCH[276:290], type="l")
plot(timeseries$GDPC1_PCH[276:286], type="l")
```


```{r}
library(reshape2)
library(ggplot2)

burn <- SuggestBurn(0.1, bsts.reg)
### Helper function to get the positive mean of a vector
PositiveMean <- function(b) {
  b <- b[abs(b) > 0]
  if (length(b) > 0) 
    return(mean(b))
  return(0)
}

### Get the average coefficients when variables were selected (non-zero slopes)
coeff <- data.frame(melt(apply(bsts.reg$coefficients[-(1:burn),], 2, PositiveMean)))
coeff$Variable <- as.character(row.names(coeff))
ggplot(data=coeff, aes(x=Variable, y=value)) + 
  geom_bar(stat="identity", position="identity") + 
  theme(axis.text.x=element_text(angle = -90, hjust = 0)) +
  xlab("") + ylab("") + ggtitle("Average coefficients")
```

```{r}
components.withreg <- cbind.data.frame(
  colMeans(bsts.reg$state.contributions[-(1:burn),"trend",]),
  colMeans(bsts.reg$state.contributions[-(1:burn),"seasonal.4.1",]),
  colMeans(bsts.reg$state.contributions[-(1:burn),"regression",]),
  as.Date(time(timeseries$DATE[149:296])))  
names(components.withreg) <- c("Trend", "Seasonality", "Regression", "Date")
components.withreg <- melt(components.withreg, id.vars="Date")
names(components.withreg) <- c("Date", "Component", "Value")

ggplot(data=components.withreg, aes(x=Date, y=Value)) + geom_line() + 
  theme_bw() + theme(legend.title = element_blank()) + ylab("") + xlab("") + 
  facet_grid(Component ~ ., scales="free") + guides(colour=FALSE) + 
  theme(axis.text.x=element_text(angle = -90, hjust = 0))
```


